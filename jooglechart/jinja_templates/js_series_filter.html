
		/*
			For the series filter, we will use a category filter.  We
			have to create a special DataTable out of the main data column
			that will be used by the series filter.
			
			The series filter is not bound to data, so it doesn't dirctly
			filter any data.  Instead, it triggers a callback to
			create a new view for redrawing the chart(s).
		*/

		var series_filter_table = new google.visualization.DataTable({{ jg._series_filter._filter_table_json }});
		
		{# if there's a global name don't use var #}
		{% if jg._series_filter._global_name %}
	    {{ jg._series_filter._name }} = new google.visualization.ControlWrapper({
		{% else %}
	    var {{ jg._series_filter._name }} = new google.visualization.ControlWrapper({		
		{% endif %}
	      controlType: 'CategoryFilter',
	      containerId: '{{ jg._series_filter._div_id }}',
	      dataTable: series_filter_table,
	      options: {{ jg._series_filter._options|default("{}")|to_json }},
	      state: {{ jg._series_filter._state|default("{}")|to_json }}
	    });

	    {{ jg._series_filter._name }}.draw();

		// pass an array of the series' columns in the orignal datatable from python
		// series cols are the viewable, non-role, non-category cols
		var series_cols = {{ jg._series_filter._series_indexes|to_json }};

		// initialize the array of dataTable column indices, e.g, [0, 1, 2, etc.]
	    var columns = [];
	    for (var i = 0; i < {{ jg.data_name }}.getNumberOfColumns(); i++) {
	        columns.push(i);
	    }

		// an object of series properties will be passed to the chart wrapper for setting color
	    var series = {};

		function series_filter_update_chart() {
			
			var selectedValues = {{ jg._series_filter._name }}.getState().selectedValues;

			// Loop through series cols
			for (var i = 0; i < series_cols.length; i++) {
				
				// initialize series object
				series[i] = {}
				
				// get series column index in the original data table
				var ix = series_cols[i]
								
				// check if series has been selected
				var test_val = {{ jg.data_name }}.getColumnLabel(ix);
				if ($.inArray(test_val, selectedValues) >= 0) {
					// if the series is selected, just pass the normal column
					// and get the default color
					columns[ix] = ix;
					series[i].color = null;
				} else {
					
					// create a column object that returns null, hiding the series on the chart
	                columns[ix] = {
	                    label: {{ jg.data_name }}.getColumnLabel(ix),
	                    type: {{ jg.data_name }}.getColumnType(ix),
	                    calc: function () {
	                        return null;
	                    }
	                };
					
					// gray out the series color for the legend
					series[i].color = '#CCCCCC';
				}
				
			}

            var view = new google.visualization.DataView({{ jg.data_name }});
            view.setColumns(columns);

            {% for chart in jg.charts %}
				{{ chart.name }}.setDataTable(view);
				{{ chart.name }}.setOption('series', series);
            {% endfor %}
            {% if jg.filters %}
				{{ jg.dashboard_name }}.draw(view);
            {% else %}
	            {% for chart in jg.charts %}
	            {{ chart.name }}.draw();
	            {% endfor %}
            {% endif %}
            
            {% for sender in jg._series_filter._senders %}
            joogle_globals.sonar.send("{{ sender.key }}", selectedValues);
            {% endfor %}
			
			
		}
		
		/*
			including both ready and statechange listeners as hack. The statechange event won't fire
			for the SuperCategoryFilter but the ready event will.
		*/
	    google.visualization.events.addListener({{ jg._series_filter._name }}, 'ready', series_filter_update_chart);
	    google.visualization.events.addListener({{ jg._series_filter._name }}, 'statechange', series_filter_update_chart);
		series_filter_update_chart();