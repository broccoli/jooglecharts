
<script>

$(document).ready(function() {

	/* GLOBALS AREA >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

	window.addEventListener('message', function(message) {
		// listener for sonar message from iframe parent
		if (typeof message.data.msg !== "undefined" && typeof message.data.msg.sonar_key !== "undefined" && 
				typeof message.data.msg.sonar_value !== "undefined" && 
				message.data.originId !== message.data.destinationId) {
			if (joogle_globals.sonar.handler_array !== undefined) {
				joogle_globals.sonar.call_handlers(message.data.msg);
			}
		}
	});

	{% if refresh_globals %}
		window.joogle_globals = null;
	{% endif %}

	if (typeof window.joogle_globals === "undefined" || window.joogle_globals === null) {
		window.joogle_globals = {};
	
		window.joogle_globals.sonar = new (function () {
			// object for holding all sonar pieces
			this.handler_array = [];
			this.message_map = {};
			this.add_handler = function(handler) { this.handler_array.push(handler)};
			this.send = function(key, value) {
				this.message_map[key] = value;
				var data = { sonar_key: key, sonar_value: value };
				if (window.self !== window.top) {
					window.parent.postMessage(data, window.location.origin + window.location.pathname);
				}
				if (joogle_globals.sonar.handler_array !== undefined) {
					joogle_globals.sonar.call_handlers(data);
				}
			}
			this.call_handlers = function(data) {
				for (var i = 0; i < this.handler_array.length; i++) {
					this.handler_array[i](data);
				}
				this.call_text_receivers(data);
			}
			this.poll_message_map = function(key) {
				if (key in this.message_map) {
					return this.message_map[key];
				}
				else { return null};
			}
			this.add_one_time_ready_poller = function(key, func, vis) {
				/*
					Check if a sonar msg was sent before chart was ready, and run function.
					Can happen if a sender has been initialized with a value.
				*/
				google.visualization.events.addOneTimeListener(vis, "ready", function() {
					var result = joogle_globals.sonar.poll_message_map(key);
					if (result !== null) {
						func({"sonar_key": key, "sonar_value": result});
					}
				});
			}
			this.call_text_receivers = function (data) {
				$(".joogle_text_receiver").each(function() {
					var receiver = this;
					var key = receiver.dataset.key;
					var list_style = receiver.dataset.liststyle;
					var sub_text = data.sonar_value;
					var default_text = receiver.dataset.default;
					if (typeof default_text === "undefined") {
						default_text = "";
					}
					var clear_text = receiver.dataset.clear_text;
					if (sub_text.constructor !== Array) {
						sub_text = $.trim(sub_text);
						if (sub_text.length == 0) {
							sub_text = default_text;
						}
						sub_text = [sub_text];
					} else if (sub_text.length === 0) {
						sub_text = [default_text];
					}
					sub_text = joogle_globals.format_list_for_text_receiver(sub_text, list_style);
					if (key == data.sonar_key) {
						var template = receiver.dataset.template;
						template = template.replace("{}", sub_text);
						receiver.innerHTML = template;
					}
				})
			}
		})();
	}
	
	window.joogle_globals.format_list_for_text_receiver = function(arr, list_style) {
		if (list_style === "colloquial") {
			if (arr.length === 1) { return arr[0]; }
			var front = "";
			var back = "";
			var back_arr = arr.slice(arr.length - 2, arr.length);
			back = back_arr[0] + " and " + back_arr[1];
			if (arr.length > 2) {
				var front_arr = arr.slice(0, arr.length - 1);
				for (var i = 0; i < front_arr.length; i++) {
					front += front_arr[i] + ", ";
				}
			}
			return front + back;
		}
		else if (list_style === "parens") {
			return "(" + arr.join(", ") + ")";
		}
		else if (list_style === "brackets") {
			return "[" + arr.join(", ") + "]";
		}
	}

	window.joogle_globals.update_category_filter = function(filter, selected_values) {
		// utility function for updating Google Charts filter		
		var filter_state = filter.getState();
		filter_state.selectedValues = selected_values;
		filter.setState(filter_state);
		filter.draw();
	}
	window.joogle_globals.update_range_filter = function(filter, range) {
		// utility function for updating Google Charts filter		
		var filter_state = filter.getState();
		filter_state.lowValue = range[0];
		filter_state.highValue = range[1];
		filter_state.lowThumbAtMinimum = false; // buggy without this
		filter_state.highThumbAtMaximum = false;
		filter.setState(filter_state);
		filter.draw();
	}
	window.joogle_globals.update_filter_binding_selection = function(selected_values, data, filter, column) {
		// Method for filtering controlWrapper's dataTable and redrawing.  Used for filter sonar receiver.
		
		var filtered_rows = [];
		if (selected_values.length == 0) {
			filtered_rows = null;
		}
		else {
			for (var i = 0; i < selected_values.length; i++) {
				var rows = data.getFilteredRows([{column: column, value: selected_values[i]}]);
				filtered_rows = $.merge(filtered_rows, rows);
			}
		}
		// undocumented setView method on control wrappers
		filter.setView({
			rows: filtered_rows
		});

		filter.draw();
	}
	window.joogle_globals.update_chart = function(values_arr, data, chartwrapper, column, view_cols) {
		var filtered_rows = joogle_globals.get_rows_for_column_selections(column, values_arr, data);
		chartwrapper.setView({
			rows: filtered_rows,
			columns: view_cols
		});
		chartwrapper.draw();			
	}

	window.joogle_globals.update_chart_range = function(minValue, maxValue, data, chartwrapper, column, view_cols) {
		var filtered_rows = data.getFilteredRows([{column: column, minValue: minValue, maxValue: maxValue}]);
		chartwrapper.setView({
			rows: filtered_rows,
			columns: view_cols
		});
		chartwrapper.draw();			
	}
	
	window.joogle_globals.get_rows_for_column_selections = function(column, selections, datatable) {
		var rows_total = [];
		if (selections.length == 0) {
			rows_total = null;
		}
		else {
			for (var i = 0; i < selections.length; i++) {
				var rows = datatable.getFilteredRows([{column: parseInt(column), value: selections[i]}]);
				rows_total = $.merge(rows_total, rows);
			}
		}
		return rows_total;		
	}

	window.joogle_globals.get_binding_selections = function(binding_selections, datatable) {
		// A filter's column can be bound by another sender (a filter, typically).
		// Need to get the filtering values for the bound column if it had received a filtering messsage.
		var binding_rows = [];
		var binding_values = [];
		for (var column in binding_selections) {
			if (binding_selections[column].length > 0) {
				var rows = joogle_globals.get_rows_for_column_selections(column, binding_selections[column], datatable);
				$.merge(binding_rows, rows);
			}
		}			
		// now we've got the binding rows, get the values in the right column
		for (var ix in binding_rows) {
			binding_values.push(datatable.getValue(binding_rows[ix], 0));
		}
		return binding_values;
	}

	window.joogle_globals.draw_chart_filtered_columns = function(datatable, viewable_columns, selected_columns, callback) {
		// an object of series properties will be passed to the chart wrapper for setting color
	    var series = {};
		
		// initialize the array of dataTable column indices, e.g, [0, 1, 2, etc.]
	    var columns = [];
	    for (var i = 0; i < datatable.getNumberOfColumns(); i++) {
	        columns.push(i);
	    }
		
		// Loop through series cols
		for (var i = 0; i < viewable_columns.length; i++) {
			series[i] = {}	// initialize series object
			var ix = viewable_columns[i]	// get series column index in the original data table
							
			// check if series has been selected
			var test_val = datatable.getColumnLabel(ix);
			if ($.inArray(test_val, selected_columns) >= 0) {
				// if the series is selected, just pass the normal column
				// and get the default color
				columns[ix] = ix;
				series[i].color = null;
			} else {
				// create a column object that returns null, hiding the series on the chart
                columns[ix] = {
                    label: datatable.getColumnLabel(ix),
                    type: datatable.getColumnType(ix),
                    calc: function () {
                        return null;
                    }
                };
				
				// gray out the series color for the legend
				series[i].color = '#CCCCCC';
			}	
		}
        var view = new google.visualization.DataView(datatable);
        view.setColumns(columns);
		
		callback(view, series);
	}

	window.joogle_globals.get_viewable_columns = function(chart) {
		// Get the column indexes for viewable series.  Check to see if viewable columns was specified
		// Then take out the role columns, and then drop the first column, since its a category.
		
		var datatable = chart.getDataTable();
		var view = chart.getView();
		
		// if view columns not specified, get empty array
		var view_cols = view === null ? [] : view.columns;

		if (view_cols.length === 0) {
			// if no view_cols are set, just get an array of all column numbers
			var num_cols = datatable.getNumberOfColumns();
			for (var i = 0; i < num_cols; i++){
				view_cols.push(i);
			}
		}
		
		// get the subset of view_cols that are not role columns
		var non_role_cols = [];
		for (var i = 0; i < view_cols.length; i++) {
			var role = datatable.getColumnRole(i);
			if (role === "") { non_role_cols.push(view_cols[i]); }
		}
		
		// shift off the first column of categories
		non_role_cols.shift()
		return non_role_cols;
	}

	window.joogle_globals.get_label_index_map = function(chart) {
		var datatable = chart.getDataTable();
		var num_columns = datatable.getNumberOfColumns();
		var label_index_map = {};
		for (var i = 0; i < num_columns; i++) {
			var label = datatable.getColumnLabel(i);
			label_index_map[label] = i;
		}
		return label_index_map;
	}

	/*
		The google.load function can only be called once per page.  On the first
		jooglechart, load the api and call loader with a callback.  For
		subsequent jooglecharts, just run the "callback" on its own
		after waiting to see of the google vis library is loaded.
	*/
	
	function when_google_vis_loaded (callback) {
		// check to see if google visualization library has been loaded.
		if (typeof window.google === 'undefined' || typeof window.google.visualization === 'undefined') {
			setTimeout (function () {
				when_google_vis_loaded (callback);
			}, 100); // wait 100 ms
		} else { callback (); }
	}
	
    // load visualization library    
    function google_loader(callback) {    
	    google.charts.load('44', {packages: ['table', 'corechart', 'controls', 'sankey', 'calendar', 'gauge', 'treemap']});
	    google.charts.setOnLoadCallback(callback);
    }
	
	window.joogle_globals.call_jooglechart_callback = function(callback) {
		if (typeof window.jooglechart_has_been_created === "undefined") {
			window.jooglechart_has_been_created = true;
			jQuery.getScript('https://www.gstatic.com/charts/loader.js', function( data, textStatus, jqxhr) {
		    	google_loader(callback);
			});
		} else {
			when_google_vis_loaded(callback);
		}
	}
	
{% include "js_button_group_prototype.html" %}


{% include "js_legend_prototype.html" %}

	/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<< GLOBALS AREA */

});

</script>